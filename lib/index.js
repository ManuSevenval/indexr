// TODO: break out into modules
import camelCase from 'camelcase';
import fs from 'fs';
import path from 'path';
import walkSync from 'walk-sync';

const truthy = (a) => !!a;

const localModuleName = (module) => camelCase(module.split('/')[0]);

const ensureArray = (a) => Array.isArray(a) ? a : [a];

const headerComment = () => `/**
  This file is autogenerated by indexr.
  Check this file into source control.
  Do not edit this file.
  For more information: http://github.com/ryardley/indexr
**/`;

const footerComment = () => '/** End autogenerated content **/';

const moduleArray = (modules) => {
  const localModules = modules.filter(truthy).map(localModuleName);
  return `[
  ${localModules.join(`,\n  `)}
]`;
};

const es6ImportStatement = (module) =>
  `import ${localModuleName(module)} from './${module}';`;

const es6ExportStatement = (modules) => {
  if (modules.length === 0) return '';
  return `export default ${moduleArray(modules)};`;
};

const es6ImportStatements = (modules) =>
  modules.map(es6ImportStatement).join('\n');

const es5ImportStatement = (module) =>
  `var ${localModuleName(module)} = require('./${module}');`;

const es5ExportStatement = (modules) => {
  if (modules.length === 0) return '';
  return `module.exports = ${moduleArray(modules)};`;
};

const es5ImportStatements = (modules) =>
  modules.map(es5ImportStatement).join('\n');

const templateES6 = (modules) => [
  headerComment(),
  es6ImportStatements(modules),
  es6ExportStatement(modules),
  footerComment(),
  '',
].join('\n');

const templateES5 = (modules) => [
  headerComment(),
  es5ImportStatements(modules),
  es5ExportStatement(modules),
  footerComment(),
  '',
].join('\n');

// const checkIfDir = (cwd) => (filename) =>
//   tryFunc(() => fs.statSync(path.resolve(cwd, filename)).isDirectory());

const trimTrailingSlash = (str) => str.replace(/\/$/, '');

const getFileList = (folder, globs) =>
  walkSync(folder, { globs: ensureArray(globs) }).map(trimTrailingSlash);

const fileWriter = (filename, str) => fs.writeFileSync(filename, str);

const defaultOptions = {
  fileWriter,
  include: '*/',
  template: templateES6,
  directImport: false,
  exts: [],
};

function getTemplateOutput(templateFunction, fileList) {
  return templateFunction(fileList);
}

const stripSubmodules = (directImport) => (filePath) => {
  if (directImport) return filePath;
  const m = filePath.match(/^.[^/]*/);
  return m && m[0] || filePath;
};

const stripExts = (exts) => (filePath) => {
  const extsPlusDot = [...exts, ''];
  const extsPlusDotJoined = extsPlusDot.join('|');
  const regexExts = `\\.(${extsPlusDotJoined})$`;
  return filePath.replace(new RegExp(regexExts), '') || filePath;
};

// TODO: make asynchronous
export default function indexr(inputFolder, ...rest) {
  // Parse Arguments
  const secondArg = rest[0];
  const lastArg = rest.slice(-1)[0];

  const outputFilename = typeof secondArg === 'string' ? secondArg : undefined;
  const givenOptions = typeof lastArg === 'object' ? lastArg : {};

  const options = Object.assign(
    {},
    defaultOptions,
    givenOptions,
    { template: givenOptions.es5 ? templateES5 : givenOptions.template || defaultOptions.template }
  );

  // get folder list based on inputs
  const fileList = getFileList(inputFolder, options.include);

  // modify folder output
  const modifiedFileList = fileList
    .map(stripExts(options.exts))
    .map(stripSubmodules(options.directImport));

  if (modifiedFileList.length === 0) return '';

  // render template
  const renderedTemplate = getTemplateOutput(
    options.template, modifiedFileList, options);

  // write file
  if (outputFilename !== undefined) {
    options.fileWriter(path.resolve(inputFolder, outputFilename), renderedTemplate);
  }

  // return string
  return renderedTemplate;
}
